#+LATEX_HEADER: \usepackage{mathtools, amsthm, booktabs, physics}
* *综述                                                             :ARCHIVE:
** C++ 类
*** 基本的 class 语法
- 类(class)
  - 成员(members)
    - 数据
    - 成员函数(member function): 用于处理对象, 常被称为方法(method).

- 对象(object): 类的实例
  - 类所指定的数据成分

#+begin_src cpp
  class IntCell
  {
  public:
    IntCell()
    { storedValue = 0; }
    IntCell(int initialValue)
    { storedValue = initialValue; }
    int read()
    { return storedValue; }
    void write( int x )
    { storedValue = x; }
  private:
    int storedValue;
  };
#+end_src

*** 构造函数的附加语法和访问函数
**** 默认参数
#+begin_src cpp
  class IntCell
  {
  public:
    explicit IntCell(int initialValue=0) : storedValue{initialValue}
    {}
    int read() const
    { return storedValue; }
    void write(int x)
    { storedValue = x; }
  private:
    int storedValue;
  };
#+end_src
**** 初始化表列
- 代替赋值语句
**** explicit 构造函数
- 应使所有的单参数构造函数为 ~explicit~ 的, 以避免后台类型转换.
**** 常成员函数
- 访问函数(accessor) :: 检查但不改变其对象状态的成员函数(const)
- 修改函数(mutator) :: 改变其对象状态的成员函数(默认)

*** 接口与实现的分离
#+name: IntCell.h
#+begin_src cpp
  #ifndef IntCell_H
  #define IntCell_H
  class IntCell
  {
  public:
    explicit IntCell(int initialValue=0);
    int read() const;
    void write(int x);
  private:
    int storedValue;
  };
  #endif
#+end_src

#+name: IntCell.cpp
#+begin_src cpp
  #include "IntCell.h"
  IntCell::IntCell(int initialValue) : storedValue{initialValue}
  {
  }
  int IntCell::read() const
  {
    return storedValue;
  }
  void IntCell::write(int x)
  {
    storedValue = x;
  }
#+end_src
**** 预处理命令
- 避免在编译一个文件的过程中一个接口被读两次
**** 作用域解析运算符
- ~::~
**** 特征必须完全匹配
- ~const~
**** 对象的声明同于基本类型
#+begin_src cpp
  IntCell obj1;                   // 零参数构造函数
  IntCell obj2(12);               // 单参数构造函数
  IntCell obj3 = 37;              // 不合法: 构造函数是 explicit 的
  IntCell obj4();                 // 不合法: 函数声明
  IntCell obj2{12};               // 单参数构造函数 better
  IntCell obj4{};                 // 零参数构造函数
#+end_src
*** vector 类和 string 类
#+begin_src cpp
  vector<int> daysInMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // n=12
  vector<int> daysInMonth { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; // n=12
  vector<int> daysInMonth {12};   // n=1
  vector<int> daysInMonth(12);    // n=12
#+end_src
** C++ 细节
*** 指针(pointer)
- 指针变量(pointer variable) :: 存放另一对象所占用的地址的变量.
#+begin_src cpp
  int main()
  {
    IntCell *m;
    m = new IntCell{0};
    m->write(5);
    cout << "Cell contents: " << m->read() << endl;
    delete m;
    return 0;
  }
#+end_src
**** 声明
- 星号*表示 m 是一个指针变量
**** 对象的动态创建
#+begin_src cpp
  m = new IntCell();              // OK
  m = new IntCell{};              // C++11
  m = new IntCell;                // Prefered
#+end_src
**** 垃圾收集与 delete
- ~new~ 对象不再被引用时, 必须(通过一个指针)对该对象应用 ~delete~ 操作, 否则将导致内存漏洞(memory leak).
**** 指针的赋值和比较
- 基于指针所存储的内存地址进行
**** 通过指针访问对象的成员
- ~->~
**** 取地址操作符(&)
- 返回一个对象所占用的内存地址
*** 左值、右值和引用
- 左值(lvalue) :: 标识非临时性对象的表达式.
- 右值(rvalue) :: 标识临时性对象的表达式, 或者是一个不与任何对象相联系的值(如字面值常数).


- 左值引用
  - ~&~
  - 给结构复杂的名称起别名
  - 范围 for 循环
  - 避免复制
- 右值引用
  - ~&&~

*** 参数传递
- 传值调用(call-by-value)
- 传引用调用(call-by-reference)
  - 传左值引用调用(call-by-lvalue-reference)
- 传对常量引用的调用(call-by-reference-to-a-constant)
  - 传常量引用调用(call-by-constant reference)
- 传右值引用调用(call-by-rvalue-reference)

*** 返回值传递
- 传值返回(return-by-value)
- 传常量引用返回(return-by-constant-reference)
- 传引用返回(return-by-reference)

*** std::swap 和 std::move
- std::move: 把任何左值(或右值) 转换称右值
*** 五大函数(big-five)
**** 析构函数(destructor)
**** 拷贝构造函数(copy constructor)
**** 移动构造函数(move constructor)
**** 拷贝赋值 operator=(copy assignment operator)
**** 移动赋值 operator=(move assignment operator)
**** 默认情形
- 浅拷贝(shallow copy) :: 指针指向相同的对象
- 深拷贝(deep copy) :: 整个对象的复制品
**** 当默认情形不起作用时
*** C 风格数组和字符串
** 模板
*** 函数模板
- 类型无关
- 泛型算法
*** 类模板
*** Object、Comparable 和一个例子
*** 函数对象
*** 类模板的分离式编译

* 表(List)、栈(Stack)、队列(Queue)                                  :ARCHIVE:
** 表的基本概念和性质
- 抽象数据类型(Abstract Data Type, ADT) :: 带有一组操作的的一些对象的集合.

*** 顺序表
- 随机访问
- 连续的存储空间

*** 链表
- 支持存储空间的动态分配
**** 单链表
**** 双向链表
**** 环形链表
**** 带哨兵节点的链表
**** *静态链表

** 表 ADT 及其顺序、链接实现
- ~printList~
- ~makeEmpty~
- ~find~
- ~insert~
- ~remove~
- ~findKth~

*** 简单数组实现
- 虽然数组由固定容量所创建, 但 ~vector~ 类(其内部存储一个数组) 在需要的时候可以使其内容成倍地增长.
  - 无需对表的大小进行估计.
- ~printList~, ~find~: $O(N)$
- ~findKth~: $O(1)$
- ~insert~, ~remove~: 平均: $O(N)$; 表尾: $O(1)$
- 若只在表尾(high end of the list) 进行插入删除, 此后只发生对数组的访问, 则数组是表的一种恰当实现.

*** 简单链表
- 链表由一系列节点组成, 这些节点不必在内存中相连
  - 每个节点均含
    - 表元素
    - 链(link): ~next~ 链(next link)
  - 最后一个单元的 ~next~ 链指向 ~nullptr~
- ~printList~, ~find~: $O(N)$
- ~findKth~: $O(i)$
- ~remove~: $O(1)$; 通过修改一个 ~next~ 指针来实现.
- ~insert~: $O(1)$; ~new~ 获取新节点, 两次调整 ~next~ 指针.

- 双向链表(doubly linked list) :: 每个节点持有一个指向它在表中的前驱节点的链.
  - 简化删除最后一项

*** *STL
- 标准模板库(Standard Template Library, STL) :: C++ 语言在其库中包含的一些常用数据结构的实现.
  通常被称为集合(collection) 或容器(container).

  - ~vector~ 提供表 ADT 的一种可增长的数组实现.
  - ~list~ 指 STL 中的 _双向链表_, 而 list 指表 ADT.

- 所有 STL 容器
  - ~int size() const~
  - ~void clear()~
  - ~bool empty() const~
- ~vector~ 和 ~list~
  - ~void push_back(const Object & x)~
  - ~void pop_back()~
  - ~const Object & back() const~
  - ~const Object & front() const~
- ~vector~
  - ~Object & operator[] (int idx)~
  - ~Object & at(int idx)~
  - ~int capacity() const~
  - ~void reserve(int newCapacity)~: 设置新的容量. 如果有好的估计可用, 那么它可以用于避免扩展 ~vector~.
- ~list~
  - ~void push_front(const Object)~
  - ~void pop_front()~

**** 迭代器
***** 获取迭代器
- ~iterator begin()~
- ~iterator end()~: 表示容器中的 *尾端(终端) 标记*(endmarker), 即容器中最后一项之后的位置.
  #+begin_src cpp
    for(int i = 0; i != v.size(); ++i)
      cout << v[i] << endl;
  #+end_src
  使用迭代器重写
  #+begin_src cpp
    for(vector<int>::iterator itr = v.begin(); itr != v.end(); itr.???)
      cout << itr.??? << endl;
  #+end_src

***** 迭代器方法
- ~itr++~ 和 ~++itr~
- ~*itr~
- ~itr1==itr2~
- ~itr1!=itr2~
#+begin_src cpp
  for(vector<int>::iterator itr = v.begin(); itr != v.end(); ++itr)
    cout << *itr << endl;
#+end_src
运算符重载的使用使我们能够访问当前项, 于是
#+begin_src cpp
  vector<int>::iterator itr = v.begin();
  while(itr !=v.end())
    cout << *itr++ << endl;
#+end_src

***** 需要迭代器的容器操作
- ~iterator insert(iterator pos, const Object & x)~
- ~iterator erase(iterator pos)~
- ~iterator erase(iterator start, iterator end)~

**** ~const_iterators~
- ~*itr~ 的结果不只是迭代器正在指向的项的值, 而且还有该项本身.
- 对于 ~const_iterator~, ~operator*~ 返回一个常量引用, 因而对于 ~const_iterator~ 的 ~*itr~ 不能出现在赋值语句的左边.

** 栈的基本概念和性质
- 栈(stack) 是一个带有限制的表, 它的插入和删除只能在一个位置上进行, 即只能在表的末端进行, 这个末端叫做 *栈顶* (top).
- 栈有时又叫做 *LIFO(后进先出) 表* (Last in, First out list).

** 栈 ADT 及其顺序、链接实现
- ~push~
- ~pop~
- ~top~

*** 数组实现
- ~vector~
  - ~back~
  - ~push_back~
  - ~pop_back~

*** 链表实现

** 栈的应用

*** 平衡符号

*** 后缀表达式

*** 中缀到后缀的转换

** 栈与递归
*** 函数调用

** 队列的基本概念和性质

** 队列 ADT 及其顺序、链接实现

** 队列的应用

* 线性表
** 顺序表
- 一次分配
- 连续的存储空间, 密度高
- 随机存取
- 插入删除费时
#+begin_src cpp
  #define maxSize 100
  int A[maxSize];
  int n;
#+end_src
*** 查找
*** 插入
*** 删除
*** 初始化
*** 求指定位置元素

** 链表
- 多次分配
- 节点存储空间利用率较低
- 顺序存取
- 插入删除不费时

*** 单链表
- 带头节点
  - 在第一个数据节点之前插入一个新节点和删除第一个数据节点的操作同表中部节点的操作统一.
  - 头指针不随操作改变.
#+begin_src cpp
  typedef struct LNode {
    int data;
    struct LNode *next;
  } LNode, *LinkList;
#+end_src

**** 头插
#+begin_src cpp
  void creastLinkedListF(LNode *&head) {
    LNode *p = NULL;
    int n;
    cin >> n;
    head = (LNode *)malloc(sizeof(LNode));
    head->next = NULL;
    for (int i = 0; i < n; ++i) {
      p = (LNode *)malloc(sizeof(LNode));
      cin >> p->data;
      p->next = head->next;
      head->next = p;
    }
  }
#+end_src

**** 尾插
#+begin_src cpp
  void createLinkedListR(LNode *&head) {
    LNode *p = NULL, *r = head;
    int n;
    cin >> n;
    head = (LNode *)malloc(sizeof(LNode));
    head->next = NULL;
    for (int i = 0; i < n; i++) {
      p = (LNode *)malloc(sizeof(LNode));
      cin >> p->data;
      r->next = p;
      r = r->next;
    }
    r->next = NULL;
  }
#+end_src

**** 归并
***** 递增
#+begin_src cpp
  void merge(LNode *A, LNode *B, LNode *&C) {
    LNode *a = A->next, *b = B->next, *r;
    C = A, r = C;
    while (a && b) {
      if (a->data < b->data) {
        r->next = a, r = r->next;
        a = a->next;
      } else {
        r->next = b, r = r->next;
        b = b->next;
      }
    }
    if (a->next != NULL)
      r->next = a;
    if (b->next != NULL)
      r->next = b;
  }
#+end_src

***** 递减
#+begin_src cpp
  void merge(LNode *A, LNode *B, LNode *&C) {
    LNode *a = A->next, *b = B->next, *s;
    C = A;
    while (a && b) {
      if (a->data < b->data) {
        s = a,
        a = a->next; // 对 s->next 赋值将破坏 a->next, 故将 a 先移动到 a->next
        s->next = C->next, C->next = s;
      } else {
        s = b, b = b->next;
        s->next = C->next, C->next = s;
      }
    }
    while (a != NULL) {
      s = a, a = a->next;
      s->next = C->next, C->next = s;
    }
    while (b != NULL) {
      s = b, b = b->next;
      s->next = C->next, C->next = s;
    }
  }
#+end_src

*** 双链表
#+begin_src cpp
  typedef struct DLNode
  {
    int data;
    struct DLNode *prev;
    struct DLNode *next;
  }DLNode;
#+end_src

**** 尾插
#+begin_src cpp
  void createDoublyLinkedListR(DLNode *&head) {
    DLNode *p, *r = head;
    int n;
    cin >> n;
    head = (DLNode *)malloc(sizeof(DLNode));
    head->next = NULL;
    head->prev = NULL;
    for (int i = 0; i < n; ++i) {
      p = (DLNode *)malloc(sizeof(DLNode));
      cin >> p->data;
      p->next = NULL;
      p->prev = r;
      r->next = p;
      r = r->next;
    }
  }
#+end_src

**** 查找节点

**** 插入节点

**** 删除节点

*** 循环单链表

*** 循环双链表

*** 静态链表
#+begin_src cpp
  typedef struct {
    int data;
    int next;
  } SLNode;
#+end_src

* 栈和队列
** 栈
- 只能在一端进行插入或删除操作的线性表
- 先进后出(FILO)
- 栈顶
  - 入栈
  - 出栈
- 栈底
- 数学性质
  \[ N=\frac{1}{n+1}C_{2n}^n \]


- 卡特兰(Catalan) 数 :: $n$ 个不同元素进栈后, 不同出栈序列的个数. [[https://en.wikipedia.org/wiki/Catalan_number][wikipedia]]
  \[ C_n = \frac{1}{n+1} \binom{2n}{n} = \frac{(2n)!}{(n+1)!n!} = \prod_{k=2}^n \frac{n+k}{k} \qfor n \geqslant 0 \]

*** 顺序栈
#+begin_src cpp
  int stack[maxSize];
  int top = -1;
#+end_src
**** 栈空
~top == -1~
**** 栈满
~top == maxSize - 1~
**** 非法状态(上溢和下溢)
**** 入栈
#+begin_src cpp
  stack[++top]=x;
#+end_src
**** 出栈
#+begin_src cpp
  x=stack[top--];
#+end_src
*** 链式栈
节点定义与链表相同.
**** 栈空
~lst->next == NULL~
**** 栈满
不存在
**** 入栈
#+begin_src cpp
  void push(LNode *lst, int x) {
    LNode *p;
    p = (LNode *)malloc(sizeof(LNode));
    p->next = NULL;
    // 头插法
    p->data = x;
    p->next = lst->next;
    lst->next = p;
  }
#+end_src
**** 出栈
单链表删除
*** 共享栈
- 栈底在两端
- 栈顶相遇
*** 应用
**** 符号匹配
#+begin_src cpp
  int match(char exp[], int n) {
    char stack[maxSize];
    int top = -1;
    for (int i = 0; i < n; i++) {
      if (exp[i] == '(')
        stack[++top] = '(';
      if (exp[i] == ')') {
        if (top == -1)
          return 0;
        else
          top--;
      }
    }
    return top == -1;
  }
#+end_src
**** 后缀表达式
当遇到数值的时候入栈, 当遇到运算符的时候, 连续两次出栈, 将两个出栈元素结合运算符进行运算, 将结果当成新遇到的数值入栈.
如此往复, 知道扫描到终止符号, 此时栈底元素值即为表达式的值.
#+include: "src/stack.cpp" :lines "125-153" src cpp

**** 中缀转后缀
#+include: "src/stack.cpp" :lines "183-236" src cpp

** 队列
- 先进先出(FIFO)
- 队尾(Rear)
  - 入队
- 队头(Front)
  - 出队
*** 顺序队(循环队列)
#+begin_src cpp
  int data[maxSize];
  int front;
  int rear;
#+end_src
**** 队空
~rear == front~
**** 队满
~(rear+1)%maxSize == front~
**** 入队
#+begin_src cpp
  rear = (rear + 1) % maxSize;
  data[rear] = x;
#+end_src
**** 出队
#+begin_src cpp
  front = (front + 1) % maxSize;
  x = data[front];
#+end_src

*** 链队
#+begin_src cpp
  typedef struct QNode {
    int data;
    struct QNode *next;
  } QNode;
  typedef struct {
    QNode *front;
    QNode *rear;
  } LiQueue;
#+end_src
**** 队空
~lqu->rear == NULL~ 或 ~lqu->front == NULL~
**** 队满
不存在
**** 入队
#+begin_src cpp
  lqu->rear->next = p;
  lqu->rear = p;
#+end_src
**** 出队
#+begin_src cpp
  p = lqu->front;
  if (lqu->front == lqu->rear) { // 只有一个节点时出队时
    lqu->front = lqu->rear = NULL;
  } else {
    lqu->front = p->next;
  }
  x = p->data;
  free(p);
#+end_src
*** 双端队列
*** 应用
- 打印机
- 排队
- 文件服务器
- 排队论
** 抽象数据类型
- Abstract Data Type, ADT

* 树
** 树
*** 术语
- 结点
- 叶子结点: 终端结点
- 分支结点: 非终端结点
- 内部结点: 除根节点之外的非终端结点
*** 存储结构
**** 顺序存储结构
- 双亲存储结构
**** 链式存储结构
- 孩子存储结构(邻接表)
- 孩子兄弟存储结构(树和森林, 二叉树)

** 二叉树
- 满二叉树
- 完全二叉树
*** 性质
- 非空二叉树上叶子结点数等于双分支结点数加 1.
- 二叉树的第 i 层上最多有 $2^{i-1}$ 个结点.
- 高度为 k 的二叉树最多有 $2^k-1$ 个结点.
- 有 n 个结点的完全二叉树, 对各结点从上到下, 从左到右依次编号(1~n), 则编号为 i 的 a 节点
  - 若 $i \neq 1$, 则 a 双亲节点的编号为 $\lfloor \frac{i}{2} \rfloor$.
  - 若 $i \leqslant \frac{n}{2}$, 则 a 左孩子的编号为 $2i$.
  - 若 $i \leqslant \frac{n-1}{2}$, 则 a 右孩子的编号为 $2i+1$.
- 数学性质: Catalan 给定 n 个结点, 能构成 C(n) 种不同的二叉树.
- 有 n 个结点的完全二叉树的高度为 $\lfloor \log_2 n \rfloor + 1$.
*** 存储结构
**** 顺序存储结构
- 完全二叉树
  将完全二叉树的结点值按编号依次存入一个一维数组中即可.
**** 链式存储结构
#+begin_src cpp
  typedef struct BTNode {
    char data;
    struct BTNode *lchild;
    struct BTNode *rchild;
  } BTNode;
#+end_src
*** 遍历算法
**** 先序遍历
- 根左右
#+begin_src cpp
  void preorder(BTNode *p) {
    if (p != NULL) {
      Visit(p);
      preorder(p->lchild);
      preorder(p->rchild);
    }
  }
#+end_src
***** 非递归(栈)
- 入栈顺序: 根右左
#+begin_src cpp
  void preorderNonRecursion(BTNode *bt) {
    if (bt != NULL) {
      BTNode *stack[maxSize], *p;
      int top = -1;
      stack[++top] = bt;
      while (top != -1) {
        p = stack[top--];
        Visit(p);
        if (p->rchild != NULL)
          stack[++top] = p->rchild;
        if (p->lchild != NULL)
          stack[++top] = p->lchild;
      }
    }
  }
#+end_src

**** 中序遍历
- 左根右
***** 非递归
- 入栈顺序: 根 左...左 右
#+begin_src cpp
  void inorderNonRecursion(BTNode *bt) {
    if (bt != NULL) {
      BTNode *stack[maxSize], *p = bt;
      int top = -1;
      while (top != -1 || p != NULL) {
        while (p != NULL) {
          stack[++top] = p;
          p = p->lchild;
        }
        if (top != -1) {
          p = stack[top--];
          Visit(p);
          p = p->rchild;
        }
      }
    }
  }
#+end_src
**** 后序遍历
- 左右根
***** 表达式树求值
#+begin_src cpp
  int comp(BTNode *p) {
    int A, B;
    if (p != NULL) {
      if (p->lchild != NULL && p->rchild != NULL) {
        A = comp(p->lchild);
        B = comp(p->rchild);
        return op(A, B, p->data);
      } else
        return p->data - '0';
    } else
      return 0;
  }
#+end_src
***** 求二叉树深度
- D=max{LD,RD}+1
***** 非递归
- 逆后序遍历序列为先序遍历过程中队左右子树遍历顺序交换所得到的结果.
#+begin_src cpp
  void postorderNonRecursion(BTNode *bt) {
    if (bt != NULL) {
      BTNode *stack1[maxSize], *stack2[maxSize];
      int top1 = -1, top2 = -1;
      BTNode *p = NULL;
      stack1[++top1] = bt;
      while (top1 != -1) {
        p = stack1[top1--];
        stack2[++top2] = p;
        if (p->lchild)
          stack1[++top1] = p->lchild;
        if (p->rchild)
          stack1[++top1] = p->rchild;
      }
      while (top2 != -1) {
        p = stack2[top2--];
        Visit(p);
      }
    }
  }
#+end_src

**** 层次遍历
- 循环队列
#+begin_src cpp
  void level(BTNode *p) {
    int front, rear;
    BTNode *que[maxSize];
    front = rear = 0;
    BTNode *q;
    if (p != NULL) {
      rear = (rear + 1) % maxSize;
      que[rear] = p; // 根节点入队
      while (front != rear) {
        front = (front + 1) % maxSize;
        q = que[front]; // 出队
        Visit(q);
        if (q->lchild != NULL) {
          rear = (rear + 1) % maxSize;
          que[rear] = q->lchild;
        }
        if (q->rchild != NULL) {
          rear = (rear + 1) % maxSize;
          que[rear] = q->rchild;
        }
      }
    }
  }
#+end_src

***** 求二叉树宽度
1. 求每个结点的层号存于队列数组中.
2. 求层数出现次数的最大值.
   
** 普通树与二叉树的转换
*** 树转换为二叉树( _孩子兄弟_ 存储结构)
1. 将同一结点的各孩子结点连接
2. 将每个结点的分支从左往右除第一个外, 其余都剪掉.
3. 调整结点使之符合二叉树的层次结构
*** 二叉树转换为树
*** 森林转换为二叉树
1. 将所有树转化为二叉树
2. 将第二棵二叉树作为第一棵二叉树根结点的右子树, 第三棵作为第二棵的右子树, 以此类推.
*** 二叉树转换为森林

** 树和森林的遍历
*** 树的遍历
**** 先序遍历
对应转换成二叉树后的先序遍历
**** 后序遍历
对应转换成二叉树后的 _中序遍历_
*** 森林的遍历
**** 先序遍历
**** 后序遍历(中序遍历)

** 树的应用, Huffman 树的定义与应用
- 树的应用: 二叉排序树, 平衡二叉树.

*** Huffman 树
**** 概念
- 路径 :: 从树中一个结点到另一个结点的分支所构成的路线.
- 路径长度 :: 路径上的分支数目.
- 树的带权路径长度(WPL) :: 树中所有叶子结点的带权路径长度之和.
**** 构造方法
1. 选最小 2 个结点作为左右子树构成一个新结点, 权值为两个结点权值之和.
2. 删去已选的两个结点, 加入新构造的结点.
3. 重复到只剩一棵树.
**** 特点
1. 权值越大, 距离根结点越近.
2. 没有度为 1 的结点: 正则(严格) 二叉树.
3. 树的带权路径长度最短.
**** 编码
1. 以字符为结点, 以对应的出现次数为权值, 构造 Huffman 树.
2. 左 0 右 1.
- Huffman 编码产生的恰好为最短前缀码.
**** n 叉树
1. 补权值为 0 的结点.
2. 选权值最小的 n 个结点

* 图
** 图的基本概念
- 图(Graph)
  - 结点(Vertex)
  - 边(Edge)
- 有向图和无向图
- 弧(Arc)和边
- 顶点的度、入度和出度
- 有向完全图
  - n 个顶点
  - n(n-1) 条边
- 无向完全图
  - n(n-1)/2 条边
- 路径: 相邻顶点序偶
- 路径长度: 路径上边的数目
- 简单路径: 顶点不重复出现
- 回路
- 连通: 有路径
- 连通图: 任意两个顶点之间都连通
- 强连通图: 有向图中两个顶点相互有路径
- 连通分量: 极大连通子图
- 权: 边附带的数
- 网: 带权图

** 图的存储结构
*** 邻接矩阵
- ~A[i][j]=1~
- 顺序存储结构
- i 行和==出度, j 列和==入度
#+begin_src cpp
  typedef struct {
    int num;
    char info
  } VertexType;
  typedef struct {
    int edges[maxSize][maxSize];
    int n, e;
    VertexType vex[maxSize];
  } MGraph;
#+end_src
*** 邻接表
- 链式存储结构
- 队每个顶点建立一个单链表
#+begin_src cpp
  typedef struct ArcNode {
    int adjvex;
    struct ArcNode *nextarc;
    int info;
  } ArcNode;
  typedef struct {
    char data;
    ArcNode *firstarc;
  } VNode;
  typedef struct {
    VNode adjlist[maxSize];
    int n, e;
  } AGraph;
#+end_src

** 图的遍历
*** 深度优先遍历(DFS)
- 类似于二叉树的先序遍历
- 深度优先搜索生成树
#+begin_src cpp
  int visit[maxSize];
  void DFS(AGraph *G, int v) {
    ArcNode *p;
    visit[v] = 1;
    Visit(v);
    p = G->adjlist[v].firstarc;
    while (p != NULL) {
      if (visit[p->adjvex] == 0)
        DFS(G, p->adjvex);
      p = p->nextarc;
    }
  }
#+end_src
*** 广度度优先遍历(BFS)
- 类似于树的层次遍历
#+begin_src cpp
  void BFS(AGraph *G, int v0, int vis[maxSize]) {
    ArchNode *p;
    int que[maxSize], front = 0, rear = 0;
    int v;
    Visit(v0);
    visit[v0] = 1;
    rear = (rear + 1) % maxSize;
    que[rear] = v0;
    while (front != rear) {
      front = (front + 1) % maxSize;
      v = que[front];
      p = G->adjlist[v].firstarc;
      while (p != NULL) {
        if (visit[p->adjvex] == 0) {
          Visit(p->adjvex);
          visit[p->adjvex] = 1;
          rear = (rear + 1) % maxSize;
          que[rear] = p->adjvex;
        }
        p = p->nextarc;
      }
    }
  }
#+end_src

** 最小生成树(无向图)
*** Prim 算法
1. 任取一个顶点, 当成树.
2. 从于这颗树相接的边中选取一条最短的边, 将这条边及其所连接的顶点也并入这棵树中.
3. 重复第二步.
#+begin_src cpp
  void Prim(MGraph g, int v0, int &sum) {
    int lowcost[maxSize], vset[maxSize], v;
    int min;
    v = v0;
    for (int i = 0; i < g.n; i++) {  // v0到其他顶点的边作为候选边
      lowcost[i] = g.edges[v0][i];
      vset[i] = 0;
    }
    vset[v0] = 1;
    sum = 0;
    for (int i = 0; i < g.n - 1; i++) {
      min = INF;
      for (int j = 0; i < g.n; j++) {  // 从候选边中挑出最小的并入生成树中
        if (vset[j] == 0 && lowcost[j] < min) {
          min = lowcost[j];
          v = j;
        }
      }
      vset[v] = 1;
      sum += min;  // 记录最小生成树的权值
      for (int j = 0; j < g.n; j++) {  // 以刚并入的顶点为媒介更新候选边
        if (vset[j] == 0 && g.edges[v][j] < lowcost[j])
          lowcost[j] = g.edges[v][j];
      }
    }
  }
#+end_src
- 复杂度: O(n^2), 只与顶点有关系, 适用于稠密图.
*** Kruskal 算法
1. 每次找出候选边中权值最小的边, 就将该边并入生成树中.
2. 重复直到所有边都检测完.
- 并查集
#+begin_src cpp
  typedef struct {
    int a, b;
    int w;
  } Road;
  Road road[maxSize];
  int v[maxSize]; // 并查集
  int getRoot(int a) {
    while (a != v[a])
      a = v[a];
    return a;
  }
  void Kruskal(MGraph g, int &sum, Road road[]) {
    int sum = 0;
    for (int i = 0; i < g.n; i++)
      v[i] = i;
    sort(road, g.e);
    for (i = 0; i < g.e; i++) {
      int ra = getRoot(road[i].a);
      int rb = getRoot(road[i].b);
      if (ra != rb) {
        v[ra] = rb;
        sum += road[i].w;
      }
    }
  }
#+end_src
- 时间复杂度: sort(), 规模由图的边数 e 决定, 适用于稀疏图.

** 最短路径问题
*** 广度优先遍历算法

*** Dijkstra 算法
- 类比 Prim
- 某一顶点到其余各点的最短路径
**** 思想
- S: 已找到最短路径的点
- T: 剩余的点


1. S 只包含源点 v_0
2. 从 T 中选取到顶点 v_0 路径长度最短的顶点 v_u 并入 S
3. S 每并入一个新的顶点 v_u 都要修改顶点 v_0 到 T 中顶点的最短路径长度值.
4. 重复直到 T 的顶点全部并入 S.
**** 执行过程
- dist[v_i]: 已找到的从 v_0 到每个终点 v_i 的最短路径长度 (lowcost)
- path[v_i]: v_i 的前一个顶点
- set[]: 0:T 1:S (vset)
#+begin_src cpp
  void Dijkstra(MGraph g, int v0, int dist[], int path[]) {
    int set[maxSize];
    int min, v;
    for (int i = 0; i < g.n; i++) {
      dist[i] = g.edges[v0][i];
      set[i] = 0;
      if (g.edges[v0][i] < INF)
        path[i] = v0;
      else
        path[i] = -1;
    }
    set[v0] = 1;
    path[v0] = -1;
    for (int i = 0; i < n - 1; i++) {
      min = INF;
      for (int j = 0; j < n; j++) {
        if (set[j] == 0 && dist[j] < min) {
          v = j;
          min = dist[j];
        }
      }
      set[v] = 1;
      for (int j = 0; j < n; j++) {
        if (set[j] = 0 && dist[v] + g.edges[v][j] < dist[j]) {
          dist[j] = dis[v] + g.edges[v][j];
          path[j] = v;
        }
      }
    }
  }
#+end_src
**** 复杂度
O(n^2)

*** Floyd 算法
- 任意一对顶点间的最短路径
- A[i][j]: 已经求得的任意两个顶点 i 到 j 的最短路径的长度
- Path[i][j]: 当前两顶点 i 到 j 间最短路径上要经过的中间顶点
#+begin_src cpp
  void Floyd(MGraph g, int Path[][maxSize]) {
    int A[maxSize][maxSize];
    for (int i = 0; i < g.n; i++) {
      for (int j = 0; j < g.n; j++) {
        A[i][j] = g.edges[i][j];
        Path[i][j] = -1;
      }
    }
    for (int k = 0; k < g.n; k++)
      for (int i = 0; i < g.n; i++)
        for (int j = 0; j < g.n; j++)
          if (A[i][j] > A[i][k] + A[k][j]) {
            A[i][j] = A[i][k] + A[k][j];
            Path[i][j] = k;
          }
  }
#+end_src
- 时间复杂度: O(n^3)

** 拓扑排序
*** AOV(Activity On Vertex network) 网
- 顶点: 表示活动
- 边: 表示活动从先后次序
- 有向无环图
*** 核心算法
1. 从有向图中选择一个没有前驱的顶点输出
2. 删除 1) 中的结点, 并删除从该顶点出发的全部边
3. 重复, 直到没有入度为 0 的顶点
#+begin_src cpp
  typedef struct {
    char data;
    int inCount;
    ArcNode *firstarc;
  } VNode;

  int TopSort(AGraph *G) {
    int n = 0, v;
    int stack[maxSize], top = -1;
    ArcNode *p;
    for (int i = 0; i < G->n; i++)
      if (G->adjlist[i].inCount == 0)
        stack[++top] = i;
    while (top != -1) {
      v = stack[top--];
      n++;
      cout << v << " ";
      p = G->adjlist[v].firstarc;
      while (p != NULL) {
        v = p->adjvex;
        G->adjlist[v].inCount--;
        if (G->adjlist[v].inCount == 0)
          stack[++top] = v;
        p = p->nextarc;
      }
    }
    if (n == G->n)
      return 1;
    else
      return 0;
  }
#+end_src
** *关键路径
*** AOE(Activity On Edge network) 网
- 顶点: 表示事件
- 边: 表示活动
- 有向无环图
*** 核心算法
1. 求拓扑有序序列和拓扑有序序列
   1. 事件最早发生时间: 入边的权值 + 入边顶点的最早发生时间
   2. 事件最迟发生时间: 出边顶点的最迟发生时间 - 出边的权值
2. 找到最早发生时间和最迟发生时间相同的活动, 即为关键活动
3. 由关键活动所连成的路径即为关键路径.
*** 两个最
1. 图中的最长路径
2. 整个工期所完成的最短时间

* 查找
** 查找的基本概念
给定一个值 k, 在含有 n 个记录的表中找出关键字等于 k 的记录.
- 选择方法
  - 表的数据结构(组织方式)
  - 表中关键字是否有序


- 平均比较次数/平均查找长度(ASL) :: \[ \sum_{i=1}^n p_ic_i \]
  - p_i: 查找第 i 个记录的概率
  - c_i: 找到第 i 个记录所需进行的比较次数, 即查找长度

** 对线性关系结构的查找
*** 顺序查找
- 无序
- ASL_1: $\sum_{i=1}^n \frac{i}{n}=\frac{(n+1)}{2}$
- ASL_2: n
- 时间: O(n)

*** 二分查找(折半查找)
- 有序
#+begin_src cpp
  int BinSearch(int A[], int n, int key) {
    int low = 0, high = n - 1, mid;
    while (low <= high) {
      mid = (low + high) / 2;
      if (key == A[mid])
        return mid;
      if (key > A[mid])
        low = mid + 1;
      else
        high = mid – 1;
    }
    return -1;
  }
#+end_src
- 判定树
  - 比较次数为从根结点到待查找元素所经过的结点数
  - 复杂度即为树的高度
- ASL: $\log_2(n+1)-1$
- 时间: $O(\log_2n)$

** 二叉排序树(BST)
*** 定义
1. 若左子树不空, 则左子树上所有关键字的值均小于根关键字的值.
2. 若右子树不空, 则右子树上所有关键字的值均大于根关键字的值.
3. 左右子树又各是一颗二叉排序树.
*** 存储结构
与二叉树类似(孩子存储结构).
*** 查找关键字算法
#+begin_src cpp
  BTNode *BSTSearch(BTNode *bt, int key) {
    if (bt == NULL)
      return NULL;
    else {
      if (bt->key == key)
        return bt;
      else if (key < bt->key)
        return BSTSearch(bt->lchild, key);
      else
        return BSTSearch(bt->rchild, key);
    }
  }
#+end_src
*** 插入关键字算法
- 对于一个不存在于二叉排序树中的关键字, 其查找不成功的位置即为要插入的位置
#+begin_src cpp
  int BSTInsert(BTNode *&bt, int key) {
    if (bt == NULL) {
      bt = (BTNode *)malloc(sizeof(BTNode));
      bt->lchild = bt->rchild = NULL;
      bt->key = key;
      return 1;
    } else {
      if (bt->key == key)
        return 0;
      else if (key < bt->key)
        return BSTInsert(bt->lchild, key);
      else
        return BSTInsert(bt->rchild, key);
    }
  }
#+end_src
- 总是插入在叶子结点上.
*** 删除关键字的操作
1. 叶子结点: 直接删除
2. 只有一颗子树: 删除后将子树连接到其双亲结点
3. 有两颗子树:
   1. 沿左(右)子树的右(左)指针一直往右(左)走
   2. 用此结点的关键字替换待删除的关键字
   3. 判断此结点是否为叶子结点, 转化为 1)/2)

** 平衡二叉树(AVL)
- 特殊的二叉排序树
- 左右子树高度之差的绝对值不超过 1
- 平衡因子: 左子树的高度 - 右子树的高度
*** 平衡调整
1. 找出插入新结点后 _失去平衡的最小子树_
   - 最小不平衡二叉树: 以距离插入结点最近, 且不平衡的结点作为根的子树
2. 调整, 使之成为平衡子树
   - 当 _失去平衡的最小子树_ 被调整为平衡子树后, 无须调整原有其他所有的不平衡树
   - (对三个相关结点中序遍历, 取中间的为根结点)
   - LL : 新插入结点在 _最小不平衡二叉树_ 的左孩子的左子树上; 右单旋转调整
   - RR : 新插入结点在 _最小不平衡二叉树_ 的右孩子的右子树上; 左单旋转调整
   - LR : 新插入结点在 _最小不平衡二叉树_ 的左孩子的右子树上; 先左后右双旋转调整
   - RL : 新插入结点在 _最小不平衡二叉树_ 的右孩子的左子树上; 先右后左双旋转调整

** 散列表
- 根据给定的关键字来计算出关键字在表中的位置
*** 建立方法
- H(key)
*** 常见的 Hash 函数
**** 直接定址法
- H(key)=key 或 H(key)= a \times key + b
**** 随机数法(数字分析法)
- 选取关键字的若干位组成 Hash 地址, 使得到的 Hash 地址尽量减少冲突, 即所选数位上的数字尽可能随机.
**** *平方取中法
**** *除留余数法
- H(key)= key Mod p (p \leq m 且为素数);

*** 冲突与解决冲突的方法
当 key1 \neq key2, 而 H(key1)=H(key2)
- 二次聚集现象 :: 冲突处理后所得到的另一个 Hash 地址 H_1 仍然发生冲突, 只能再求下一个地址 H_2, 以此类推,
  直到 H_n 不发生冲突为止, H_n 即为记录在表中的 Hash 地址.

**** 闭散列方法/开放定址法
- 以发生冲突的 Hash 地址为自变量, 通过某种冲突解决函数得到一个新的空闲的 Hash 地址.
***** 线性探查法
- 从发生冲突的地址开始依次探查 d 的下一个地址, 直到找到一个空位置.
- H_i(k)=(H(k)+i) Mod m (i\leq i \leq m-1)
- 容易产生堆积问题
***** 平方探查法
- 设发生冲突的地址为 d, 则新的地址序列为 d\pm1^2, d\pm2^2, ...
- 减少出现堆积问题
- 不能探查到 Hash 表上的所有单元, 但至少能探查到一半的单元.
***** 伪随机序列法
***** 双 Hash 函数法
- H(H(k))

**** 开散列方法/拉链法(链地址法)
- 把所有的同义词用单链表连接起来
- 存放同义词单链表的表头指针, 而非记录本身

*** 性能分析
- 与关键字个数无关
- 与装填因子有关
  - 装填因子 :: 关键字个数和表长度的比值

** 优先队列
*** 插入(入队)
*** 删除最小值(出队)

** 范围查询
* 排序
** 排序基本概念
- 稳定性 :: 两个或两个以上相同关键字, 排序前后的相对位置.
** 插入排序
在已经有序的序列中, 插入新的关键字.
*** 直接插入排序
#+begin_src cpp
  void InsertSort(int A[], int n) {
    for (int i = 1; i <= n - 1; i++) {
      if (A[i] < A[i - 1]) {
        int temp = A[i];  // 待插入关键字
        int j = i - 1;
        while (j >= 0 && temp < A[j]) {  // 后移
          A[j + 1] = A[j];
          j--;
        }
        A[j + 1] = temp;
      }
    }
  }
#+end_src
- 时间: O(n^2)
  - 最好(已有序): O(n)
  - 最坏(逆序): O(n^2)
- 空间: O(1)
- 稳定
*** 折半插入排序
用折半查找法在有序序列中查找插入位置
- 时间: O(n^2)
  - 关键字移动次数于直接插入排序相同
  - 最好: $O(n\log_2n)$
- 空间: O(1)
** 希尔排序
- 缩小增量排序
- 时间
  - 与增量选取有关
  - Shell: O(n^2)
  - Papernov & Stasevich: O(n^1.5)
- 空间: O(1)
- _不稳定_

** 堆排序
- 二叉堆 :: 任何一个非叶子结点的值都不大于(或不小于) 其左右孩子结点的值的完全二叉树.
  - 大顶堆, 小顶堆
执行过程:
1. 建堆: 创建完全二叉树后调整为大顶堆
2. 插入结点: 插入到最后, 再依次调整
3. 删除: 将最后的结点值赋值给要删除的结点, 并调整, 最后删除
4. 排序: 每趟排序将堆顶与最后一个结点交换, 使堆顶达到其最终位置;
   再将除已达到最终位置的元素重新调整为大顶堆
#+begin_src cpp
  void HeapSort(int A[], int n) {   // 设 A[1] 为堆顶
    for (int i = n / 2; i > 0; i--) // 建堆
      HeapAdjust(A, i, n);
    for (int i = n; i > 1; i--) {
      int temp = A[1];
      A[1] = A[i];
      A[i] = temp;
      HeapAdjust(A, 1, i-1); // 将 A[1..i-1] 重新调整
    }
  }
  void HeapAdjust(int A[], int low, int high) {  // low 到 high 范围内对 low 的调整
    int temp = A[low];
    for (int i = 2 * low; i <= high; i = i * 2) { // i 不断取 low 的子孙结点
      if (i < high && A[i] < A[i + 1]) // 令 i 为关键字较大的结点的下标
        i++;
      if (temp >= A[i])
        break;
      else {
        A[low] = A[i];
        low = i;
      }
    }
    A[low] = temp; // 插入
  }
#+end_src
- 时间: $O(n\log_2n)$
- 空间: O(1)
- _不稳定_

** 归并排序
将两个或两个以上的有序序列合并成一个新的有序序列.
*** 二路归并排序
- 分治
#+begin_src cpp
  void mergeSort(int A[], int low, int high) {
    if (low < high) {
      int mid = (low + high) / 2;
      mergeSort(A, low, mid);
      mergeSort(A, mid + 1, high);
      merge(A, low, mid, high);  // 将两个有序序列合并成一个有序序列
    }
  }
#+end_src
- 时间: $O(n\log_2n)$, 与初始序列无关
- 空间: O(n)

** 快速排序
每一趟选择当前所有子序列中的一个关键字(通常是第一个) 作为枢轴,
将子序列中比枢轴小的移到枢轴前边, 比枢轴大的移到枢轴后边;
将得到的新的一组更短的子序列, 成为下一趟的初始序列.
- 交替扫描和交换(每趟都与枢轴比较)
- 递归(分治)
#+begin_src cpp
  void QuickSort(int A[], int n) { QSort(A, 0, n - 1); }
  void QSort(int A[], int low, int high) {
    int pivotloc;
    if (low < high) {
      pivotloc = Partition(A, low, high);  // 一趟排序后枢轴的位置
      QSort(A, low, pivotloc - 1);
      QSort(A, pivotloc + 1, high);
    }
  }
  int Partition(int A[], int low, int high) {
    int pivot = A[low];  // 枢轴内容
    // 从线性表的两端交替地向中间扫描
    while (low < high) {
      while (low < high && A[high] >= pivot)
        high--;
      A[low] = A[high];
      while (low < high && A[low] <= pivot)
        low++;
      A[high] = A[low];
    }
    A[low] = pivot;
    return low;
  }
#+end_src
- 时间: $O(n\log_2n)$
  - 最坏(有序): O(n^2)
- 空间: $O(log_2n)$
- _不稳定_

** 基数排序
多关键字排序
*** 最高位优先
先按最高位排成若干子序列, 再对每个子序列按次高位排序;
- 最高位关键字不同

*** 最低位优先
分配、收集; 从最低位到最高位依次有序
- 时间: O(d(n+r_d))
- 空间: O(r_d)
- n: 序列中的关键字数(分配)
- d: 关键字的位数(趟)
- r_d: 关键字基的个数(收集)

** *冒泡排序
#+begin_src cpp
  void BubbleSort(int A[], int n) {
    int temp, flag = 1;
    for (int i = n - 1; i >= 1 && flag == 1; i--) {  // 每趟排序将最大的关键字放到最后
      flag = 0;  // 标记本趟排序是否发生了交换
      for (int j = 0; j < i; j++) {
        if (A[j] > A[j + 1]) {
          temp = A[j];
          A[j] = A[j + 1];
          A[j + 1] = temp;
          flag = 1;
        }
      }
    }
  }
#+end_src
- 时间: O(n^2)
  - 最好: O(n)
- 空间: O(1)
- 稳定
** *简单选择排序
每一趟排序都选出一个最小的关键字, 与第一个交换.
#+begin_src cpp
  void SelectSort(int A[], int n) {
    for (int i = 0; i < n; i++) {
      int min = i;
      for (int j = i + 1; j < n; j++) {
        if (A[min] > A[j])
          min = j;
      }
      if (min != i) {
        int temp = A[min];
        A[min] = A[i];
        A[i] = temp;
      }
    }
  }
#+end_src
- 时间: O(n^2)
- 空间: O(1)
- _不稳定_

** 总结
*** 复杂度
**** 时间复杂度
***** 平均
- $O(n\log_2n)$: *快些归队*
  - 快: 快速; 些: 希尔; 归: 归并; 队: 堆
- O(d(n+r_d)): 基数排序
- O(n^2): 其他
***** 最坏(有序)
- 快速排序: O(n^2)
- 其他与平均相同
***** 最好(有序)
- O(n): 容易 *插*, *起* 的好
  - 插: 插入; 起: 冒泡
**** 空间复杂度
- 快速排序: $O(\log_2n)$
- 归并排序: O(n)
- 基数排序: O(r_d)
- 其他: O(1)

*** 稳定性
#+begin_quote
情绪不稳定, *快些选一堆* 好友来聊天
#+end_quote
- 快: 快速; 些: 希尔; 选: 简单选择; 堆: 堆

* 附录
** k 小数
- 将 n 个数排序(比如快速排序或归并排序)，选取排序后的第 k 个数，时间复杂度为 O(nlogn)。
- 维护一个 k 个元素的最大堆，存储当前遇到的最小的 k 个数，时间复杂度为 O(nlogk)。这种方法同样适用于海量数据的处理。
- 部分的快速排序（快速选择算法），每次划分之后判断第 k 个数在左右哪个部分，然后递归对应的部分，平均时间复杂度为 O(n)。但最坏情况下复杂度为 O(n^2)。
- BFPRT 算法，修改快速选择算法的主元选取规则，使用中位数的中位数的作为主元，最坏情况下时间复杂度为 O(n)。
** 约瑟夫问题
n 个人(编号为 0,1,...,n-1)围成一个圈子，从 0 号开始依次报数，每数到第 m 个人，这个人就得自杀，之后从下个人开始继续报数，直到所有人都死亡为止。
- 给出自杀顺序
- 求最后一个人的编号
[[http://maskray.me/blog/2013-08-27-josephus-problem-two-log-n-solutions][约瑟夫问题的两个O(log n)解法]]
** Mark Allen Weiss
http://users.cis.fiu.edu/~weiss/
