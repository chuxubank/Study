#+LATEX_COMPILER: xelatex
#+LATEX_HEADER: \usepackage{ctex, mathtools, amsthm, booktabs, physics, geometry}
#+LATEX_HEADER: \geometry{left=2.5cm, right=2.5cm, top=2cm, bottom=2cm}
#+OPTIONS: toc:nil

* 软件过程
** 软件过程的概念
软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。
- 活动(Activity) :: 主要实现宽泛的目标(如与利益相关者进行沟通)，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。
- 动作(Action) :: (如体系结构设计) 包含了主要工作产品(如体系结构设计模型) 生产过程中的一些列任务。
- 任务(Task) :: 关注小而明确的目标，能够产生实际产品(如构件一个单元测试)。

其目标：及时、高质量地交付软件，以满足软件项目资助方和最终用户的需求。

*** 过程框架(process framework)
- 框架活动
  - 沟通
  - 策划
  - 建模
  - 构建
  - 部署

*** 普适性活动(umbrella activity)
- 软件项目跟踪和控制
- 风险管理
- 软件质量保证
- 技术评审
- 测量
- 软件配置管理
- 可复用管理
- 工作产品的准备和生产

** 经典软件过程模型的特点
*** 瀑布模型(waterfall model)
经典生命周期(classic life cycle)
1. 沟通(用户需求规格说明书)
2. 策划(项目估算)
3. 建模(分析, 设计)
4. 构建(编码, 测试)
5. 部署(交付, 支持, 反馈)

*** 增量过程模型
交付一系列称为增量的版本, 逐步为用户提供更多功能.
- 核心产品 :: 第一个增量

*** 演化过程模型
每个迭代产生软件的一个更完整的版本
**** 原型开发
**** 螺旋模型
螺旋模型能运用在应用系统开发的整个生命周期, 从概念开发到维护

*** 统一过程模型(Unified Process)
- 用例驱动
- 以架构为核心
- 迭代并且增量


- 起始阶段 :: 客户沟通和策划活动
- 细化阶段 :: 沟通和通用过程模型的建模活动
- 构建阶段 :: 与通用软件过程中的构建活动相同
- 转换阶段 :: 包括通用构建活动的后期阶段以及通用部署(交付和反馈)活动的第一部分
- 生产阶段 :: 与通用过程的部署活动一致

** 过程评估与 CMM/CMMI 的基本概念
*** 软件过程改进(Software Process Improvement, SPI)
1. 以有效方式定义的有效过程的一些要素
2. 组织内以存在的关于软件开发的方法要依据这些要素进行评估
3. 它定义了有价值的改进策略
**** 成熟度模型(CMM)
- 第 5 级, 优化级 :: 组织具有量化的反馈系统, 能恰当识别过程的弱点, 并积极加强
- 第 4 级, 已管理级 :: 详细的软件过程和产品质量度量建立了定量评估的基础, 可预测趋势
- 第 3 级, 已定义级 :: 管理过程和工程过程已经文档化, 标准化, 已集成到了组织的标准软件过程中
- 第 2 级, 可重复级 :: 建立了基本的项目管理过程, 用以跟踪成本、进度及功能
- 第 1 级, 初始级 :: 没有定义过程, 依赖个人
*** 能力成熟度模型集成(Capability Maturity Model Integration, CMMI)
- 能力等级 0: 不完全级 :: 过程域(如需求管理) 没有执行或未达到 1 级
- 能力等级 1: 已执行级 :: 过程域的所有特定目标都已经满足. 生产已规定工作产品所需的工作任务都已执行
- 能力等级 2: 已管理级 :: 能力等级 1 中的标准都满足, 所有工作任务和产品都可被监督、控制和评审
- 能力等级 3: 已定义级 :: 能力等级 2 中的标准都满足, 根据组织剪裁准则, 对其标准过程进行了剪裁
- 能力等级 4: 定量管理级 :: 能力等级 3 中的标准都满足, 通过采用测量和定量的评估等手段, 堆过程域进行控制和改进
- 能力等级 5: 优化级 :: 能力等级 4 中的标准都满足, 采用定量(统计) 的方法调整和优化过程域, 以满足用户不断变更的需求

** 敏捷宣言与敏捷过程的特点
*** 敏捷软件开发宣言
#+begin_quote
我们正在通过亲身实践以及帮助他人实践的方式来揭示更好的软件开发之路, 通过这项工作, 我们认识到:
- 个人和他们之间的交流胜过了开发过程和工具
- 可运行的软件胜过了宽泛的文档
- 客户合作胜过了合同谈判
- 对变更的良好响应胜过了按部就班地遵循计划
也就是说,虽然上述右边的各项很有价值,但我们认为左边的各项具有更大的价值.
#+end_quote
*** 敏捷过程的特点
任何敏捷过程的特征都是以某种方式提出若干关键假设, 这些假设可适用于大多数软件项目.
- 可适应性
- 增量式开发策略

* 软件需求
** 软件需求的概念
- 系统必须符合的条件或能力
- 需求不是架构. 需求既不是设计, 也不是接口. 需求就是指需要什么.

** 需求工程的基本过程
- 起始
- 获取
- 细化
- 协商
- 规格说明
- 确认
- 管理

** 分层数据流模型

** 用例和场景建模及其 UML 表达
*** 用例图

*** 活动图

*** 泳道图

*** 顺序图

** 数据模型建模及其 UML 表达(类图)

** 行为模型建模及其 UML 表达(状态机图)

* 软件设计与构造
** 软件体系结构及体系结构风格的概念
- 软件体系结构 :: 系统的一个或多个结构, 它包括软件构件、构件的外部可见属性以及它们之间的相互关系.
  - 软件体系结构必须对系统结构以及数据和过程构件相互协作的方式进行建模.

- 体系结构风格 :: 施加在整个系统设计上的一种变换, 目的是为系统的所有构件建立一个结构.
  - 以数据为中心的体系结构
    - 数据存储为中心, 增删改查
  - 数据流体系结构
    - 管道 -- 过滤器
    - 批处理
  - 调用和返回体系结构
    - 主程序/子程序体系结构
  - 面向对象体系结构
  - 层次体系结构
    - 核心层-> 实用程序层 -> 应用层 -> 用户界面层
    - 每一层由构件组成
  
** 设计模式的概念
- 描述了解决某个特定设计问题的设计结构, 该设计问题处在一个特定环境中, 该环境会影响到模式的应用和使用方式.

** 模块化设计的基本思想及概念
*** 抽象
- 在高抽象级上, 使用问题所处环境的语言以 _概括性_ 的术语描述解决方案.
- 在较低的抽象级上, 提供更详细的解决方案说明.
- 过程抽象: 具有明确和有限功能的指令序列. ~开~ 门
- 数据抽象: 描述数据对象的具名数据集合. ~door~

*** 分解(关注点分离)
- 任何复杂问题如果被分解为可以独立解决或优化的若干块, 该复杂问题便能够更容易地得到处理
- 分而治之

*** 模块化
- 软件被划分为独立命名的、可处理的构件(模块), 把这些构件集成到一起可以满足问题的需求.
- 存在模块数量和成本(工作量) 的平衡

*** 封装

*** 信息隐藏
- 每个模块对其他所有模块都隐蔽自己的设计决策.
- 信息隐蔽的目的是将数据结构和处理过程的细节隐藏在模块接口之后, 用户不需要了解模块内部的具体细节.

*** 功能独立
- 通过开发具有“专一”功能和“避免”与其他模块过多交互的模块, 可以实现功能独立
- 软件设计时应使每个模块仅涉及需求的某个特定子集, 并且当从程序结构的其他部分观察时, 每个模块只有一个简单的接口.
- 评估
  - 内聚性
  - 耦合性

*** *求精
- /逐步求精/ 是一种自顶向下的设计策略.
- 求精实际上是一个 /细化/ 的过程
  - 每次细化提供越来越多的细节.
- 抽象和细化是互补的概念.
  - 抽象能够明确说明内部过程和数据,但对“外部使用者”隐藏了低层细节;
  - 细化有助于在设计过程中揭示低层细节.
  - 这两个概念均有助于设计人员在设计演化中构建出完整的设计模型.

*** 重构
- 重构是一种重新组织的技术, 可以简化构件的设计(或代码)而无需改变其功能或行为.
- “重构是使用这样一种方式改变软件系统的过程:不改变代码(设计)的外部行为而是改进其内部结构.”

** 软件体系结构的 UML 建模

*** 包图

*** 类图

*** 构件图

*** 顺序图

*** 部署图

** 接口的概念
- 软件的接口设计相当于一组房屋的门、窗和外部设施的详细绘图(以及规格说明).
- 接口设计元素
  1. 用户接口(User Interface, UI)
  2. 系统和外部应用的接口
  3. 系统内部构件之间的接口
- UML
  - 接口是类、构件或其他分类符(包括子系统)的外部可见的(公共的)操作说明, 而没有内部结构的规格说明.”
    - 接口是一组描述类的部分行为的操作, 并提供了这些操作的访问方法。

** 面向对象设计原则
- 有四种适用于构件级设计的基本设计原则, 这些原则在使用面向对象软件工程方法时被广泛采用.
- 使用这些原则的根本动机在于, 使得产生的设计在发生变更时能够适应变更并且减少副作用的传播.

*** 开闭原则(The Open-Closed Principle, OCP)
- 模块(构件) 应该对外延具有开放性, 对修改具有封闭性.
- 设计者应该采用一种无需对构件自身内部(代码或者内部逻辑)做修改就可以进行扩展(在构件所确定的功能域内)的方式来说明构件.
  - 抽象

*** Liskov 替换原则(Liskov Substitution Principle, LSP)
- 子类可以替换它们的基类.

*** 依赖倒置原则(Dependency Inversion Principle, DIP)
- 依赖于抽象, 而非具体实现.
- 抽象可以比较容易地对设计进行扩展, 又不会导致大量的混乱.
- 省去设计并且破解出代码, 违背类 DIP 原则.

*** 接口分离原则(Interface Segregation Principle, ISP)
- 多个客户专用接口比一个通用接口要好.
- ISP 原则建议设计者应该为每个主要的客户类型都设计一个特定的接口.
  - 只有那些与特定客户类型相关的操作才应该出现在该客户的接口说明中.
  - 如果多个客户要求相同的操作, 则这些操作应该在每个特定的接口中都加以说明.

** 内聚性与耦合性
*** 内聚性
- 构件的专一性
- 构件或者类只封装那些相互关联密切, 以及于构件或类自身又密切关系的属性和操作.
- 高内聚
**** 功能内聚
- 主要通过操作来体现, 当一个模块完成一组且只有一组操作并返回结果时, 就称此模块是功能内聚的.
**** 分层内聚
- 由包、构件和类来体现.
- 高层能够访问低层的服务, 但低层不能访问高层的服务.
**** 通信内聚
- 访问相同数据的所有操作被定义在一个类中.
  - 一般来说, 这些类只着眼于数据的查询、访问和存储.

*** 耦合性
- 类之间彼此联系程度的一种定性度量.
- 随着类(构件) 之间的相互依赖越来越多, 类之间的耦合程度亦会增加.
- 低耦合
**** 内容耦合
- 当一个构件暗中修改其他构件的内部数据.
- 违反信息隐蔽原则.
**** 控制耦合
- 当操作 A 调用 B, 并向 B 传递了一个控制标记时.
- B 的一个不相关变更会导致 A 所传递控制标记的意义发生变更.
**** 外部耦合
- 当一个构件和基础设施构件(如操作系统功能, 数据库容量, 无线通信功能) 进行通信和协作时.
- 必要, 但尽量限制在少量的构件或类范围内.

* 软件测试
** 软件测试及测试用例的概念

** 单元测试、集成测试、确认测试、系统测试、回归测试的概念

** 调试的概念、调试与测试的关系

** 测试覆盖度的概念

** 白盒测试、黑盒测试的概念

** 代码圈复杂度的计算方法

** 白盒测试中的基本路径测试方法

** 黑盒测试中的等价类划分方法
